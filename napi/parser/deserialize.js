// Code generated by `generate/index.mjs`. Do not edit.

'use strict';

module.exports = deserialize;

let uint8, uint32, float64, source, sourceIsAscii, sourceLen;

const textDecoder = new TextDecoder('utf-8', { ignoreBOM: true }),
    decodeStr = textDecoder.decode.bind(textDecoder),
    { fromCodePoint } = String;

function deserialize(buff, sourceStr, sourceByteLen) {
    uint8 = buff;
    uint32 = new Uint32Array(buff.buffer);
    float64 = new Float64Array(buff.buffer);

    source = sourceStr;
    sourceLen = sourceByteLen;
    sourceIsAscii = sourceStr.length === sourceByteLen;

    // (2 * 1024 * 1024 * 1024 - 16) >> 2
    const metadataPos32 = 536870908;
    const program = deserializeProgram(uint32[metadataPos32]);

    uint8 = uint32 = float64 = undefined;

    return program;
}

function deserializeProgram(pos) {
    return {
        type: 'Program',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        sourceType: deserializeSourceType(pos + 96),
        directives: deserializeVecDirective(pos),
        hashbang: deserializeOptionHashbang(pos + 72),
        body: deserializeVecStatement(pos + 32),
    };
}

function deserializeSourceType(pos) {
    return {
        language: deserializeLanguage(pos + 1),
        moduleKind: deserializeModuleKind(pos + 2),
        variant: deserializeLanguageVariant(pos + 3),
        alwaysStrict: uint8[pos] === 1,
    };
}

function deserializeLanguage(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'javascript';
        case 1:
            return 'typescript';
        case 254:
            return 'typescriptDefinition';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for Language`);
    }
}

function deserializeModuleKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'script';
        case 254:
            return 'module';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ModuleKind`);
    }
}

function deserializeLanguageVariant(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'standard';
        case 254:
            return 'jsx';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for LanguageVariant`);
    }
}

function deserializeVecDirective(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeDirective(pos));
        pos += 48;
    }
    return arr;
}

function deserializeDirective(pos) {
    return {
        type: 'Directive',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        expression: deserializeStringLiteral(pos),
        directive: deserializeRefStr(pos + 24),
    };
}

function deserializeStringLiteral(pos) {
    return {
        type: 'StringLiteral',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        value: deserializeRefStr(pos),
    };
}

function deserializeRefStr(pos) {
    const pos32 = pos >> 2,
        len = uint32[pos32 + 2];
    if (len === 0) return '';

    pos = uint32[pos32];
    if (sourceIsAscii && pos < sourceLen) return source.substr(pos, len);

    // Longer strings use `TextDecoder`
    // TODO: Find best switch-over point
    const end = pos + len;
    if (len > 50) return decodeStr(uint8.subarray(pos, end));

    // Shorter strings decode by hand to avoid native call
    let out = '',
        c;
    do {
        c = uint8[pos++];
        if (c < 0x80) {
            out += fromCodePoint(c);
        } else {
            out += decodeStr(uint8.subarray(pos - 1, end));
            break;
        }
    } while (pos < end);

    return out;
}

function deserializeOptionHashbang(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeHashbang(pos);
}

function deserializeHashbang(pos) {
    return {
        type: 'Hashbang',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        value: deserializeRefStr(pos),
    };
}

function deserializeVecStatement(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeStatement(pos));
        pos += 16;
    }
    return arr;
}

function deserializeStatement(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxBlockStatement(pos + 8);
        case 1:
            return deserializeBoxBreakStatement(pos + 8);
        case 2:
            return deserializeBoxContinueStatement(pos + 8);
        case 3:
            return deserializeBoxDebuggerStatement(pos + 8);
        case 4:
            return deserializeBoxDoWhileStatement(pos + 8);
        case 5:
            return deserializeBoxEmptyStatement(pos + 8);
        case 6:
            return deserializeBoxExpressionStatement(pos + 8);
        case 7:
            return deserializeBoxForInStatement(pos + 8);
        case 8:
            return deserializeBoxForOfStatement(pos + 8);
        case 9:
            return deserializeBoxForStatement(pos + 8);
        case 10:
            return deserializeBoxIfStatement(pos + 8);
        case 11:
            return deserializeBoxLabeledStatement(pos + 8);
        case 12:
            return deserializeBoxReturnStatement(pos + 8);
        case 13:
            return deserializeBoxSwitchStatement(pos + 8);
        case 14:
            return deserializeBoxThrowStatement(pos + 8);
        case 15:
            return deserializeBoxTryStatement(pos + 8);
        case 16:
            return deserializeBoxWhileStatement(pos + 8);
        case 17:
            return deserializeBoxWithStatement(pos + 8);
        case 18:
            return deserializeBoxModuleDeclaration(pos + 8);
        case 19:
            return deserializeBoxVariableDeclaration(pos + 8);
        case 21:
            return deserializeBoxFunction(pos + 8);
        case 22:
            return deserializeBoxClass(pos + 8);
        case 23:
            return deserializeBoxUsingDeclaration(pos + 8);
        case 24:
            return deserializeBoxTSTypeAliasDeclaration(pos + 8);
        case 25:
            return deserializeBoxTSInterfaceDeclaration(pos + 8);
        case 26:
            return deserializeBoxTSEnumDeclaration(pos + 8);
        case 27:
            return deserializeBoxTSModuleDeclaration(pos + 8);
        case 254:
            return deserializeBoxTSImportEqualsDeclaration(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for Statement`);
    }
}

function deserializeBoxBlockStatement(pos) {
    return deserializeBlockStatement(uint32[pos >> 2]);
}

function deserializeBlockStatement(pos) {
    return {
        type: 'BlockStatement',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        body: deserializeVecStatement(pos),
    };
}

function deserializeBoxBreakStatement(pos) {
    return deserializeBreakStatement(uint32[pos >> 2]);
}

function deserializeBreakStatement(pos) {
    return {
        type: 'BreakStatement',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        label: deserializeOptionLabelIdentifier(pos + 8),
    };
}

function deserializeOptionLabelIdentifier(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeLabelIdentifier(pos);
}

function deserializeLabelIdentifier(pos) {
    return {
        type: 'Identifier',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        name: deserializeRefStr(pos),
    };
}

function deserializeBoxContinueStatement(pos) {
    return deserializeContinueStatement(uint32[pos >> 2]);
}

function deserializeContinueStatement(pos) {
    return {
        type: 'ContinueStatement',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        label: deserializeOptionLabelIdentifier(pos + 8),
    };
}

function deserializeBoxDebuggerStatement(pos) {
    return deserializeDebuggerStatement(uint32[pos >> 2]);
}

function deserializeDebuggerStatement(pos) {
    return { type: 'DebuggerStatement', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxDoWhileStatement(pos) {
    return deserializeDoWhileStatement(uint32[pos >> 2]);
}

function deserializeDoWhileStatement(pos) {
    return {
        type: 'DoWhileStatement',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        body: deserializeStatement(pos),
        test: deserializeExpression(pos + 16),
    };
}

function deserializeExpression(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxBooleanLiteral(pos + 8);
        case 1:
            return deserializeBoxNullLiteral(pos + 8);
        case 2:
            return deserializeBoxNumericLiteral(pos + 8);
        case 3:
            return deserializeBoxBigIntLiteral(pos + 8);
        case 4:
            return deserializeBoxRegExpLiteral(pos + 8);
        case 5:
            return deserializeBoxStringLiteral(pos + 8);
        case 6:
            return deserializeBoxTemplateLiteral(pos + 8);
        case 7:
            return deserializeBoxIdentifierReference(pos + 8);
        case 8:
            return deserializeBoxMetaProperty(pos + 8);
        case 9:
            return deserializeBoxSuper(pos + 8);
        case 10:
            return deserializeBoxArrayExpression(pos + 8);
        case 11:
            return deserializeBoxArrowFunctionExpression(pos + 8);
        case 12:
            return deserializeBoxAssignmentExpression(pos + 8);
        case 13:
            return deserializeBoxAwaitExpression(pos + 8);
        case 14:
            return deserializeBoxBinaryExpression(pos + 8);
        case 15:
            return deserializeBoxCallExpression(pos + 8);
        case 16:
            return deserializeBoxChainExpression(pos + 8);
        case 17:
            return deserializeBoxClass(pos + 8);
        case 18:
            return deserializeBoxConditionalExpression(pos + 8);
        case 19:
            return deserializeBoxFunction(pos + 8);
        case 20:
            return deserializeBoxImportExpression(pos + 8);
        case 21:
            return deserializeBoxLogicalExpression(pos + 8);
        case 22:
            return deserializeBoxMemberExpression(pos + 8);
        case 23:
            return deserializeBoxNewExpression(pos + 8);
        case 24:
            return deserializeBoxObjectExpression(pos + 8);
        case 25:
            return deserializeBoxParenthesizedExpression(pos + 8);
        case 26:
            return deserializeBoxSequenceExpression(pos + 8);
        case 27:
            return deserializeBoxTaggedTemplateExpression(pos + 8);
        case 28:
            return deserializeBoxThisExpression(pos + 8);
        case 29:
            return deserializeBoxUnaryExpression(pos + 8);
        case 30:
            return deserializeBoxUpdateExpression(pos + 8);
        case 31:
            return deserializeBoxYieldExpression(pos + 8);
        case 32:
            return deserializeBoxPrivateInExpression(pos + 8);
        case 33:
            return deserializeBoxJSXElement(pos + 8);
        case 34:
            return deserializeBoxJSXFragment(pos + 8);
        case 35:
            return deserializeBoxTSAsExpression(pos + 8);
        case 36:
            return deserializeBoxTSSatisfiesExpression(pos + 8);
        case 37:
            return deserializeBoxTSTypeAssertion(pos + 8);
        case 38:
            return deserializeBoxTSNonNullExpression(pos + 8);
        case 254:
            return deserializeBoxTSInstantiationExpression(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for Expression`);
    }
}

function deserializeBoxBooleanLiteral(pos) {
    return deserializeBooleanLiteral(uint32[pos >> 2]);
}

function deserializeBooleanLiteral(pos) {
    return {
        type: 'BooleanLiteral',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        value: uint8[pos + 8] === 1,
    };
}

function deserializeBoxNullLiteral(pos) {
    return deserializeNullLiteral(uint32[pos >> 2]);
}

function deserializeNullLiteral(pos) {
    return { type: 'NullLiteral', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxNumericLiteral(pos) {
    return deserializeNumericLiteral(uint32[pos >> 2]);
}

function deserializeNumericLiteral(pos) {
    return {
        type: 'NumericLiteral',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        value: float64[(pos + 24) >> 3],
        raw: deserializeRefStr(pos),
    };
}

function deserializeBoxBigIntLiteral(pos) {
    return deserializeBigIntLiteral(uint32[pos >> 2]);
}

function deserializeBigIntLiteral(pos) {
    return {
        type: 'BigIntLiteral',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        raw: deserializeRefStr(pos),
    };
}

function deserializeBoxRegExpLiteral(pos) {
    return deserializeRegExpLiteral(uint32[pos >> 2]);
}

function deserializeRegExpLiteral(pos) {
    return {
        type: 'RegExpLiteral',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        value: deserializeEmptyObject(pos + 32),
        regex: deserializeRegExp(pos),
    };
}

function deserializeEmptyObject(pos) {
    return null;
}

function deserializeRegExp(pos) {
    return { pattern: deserializeRefStr(pos), flags: deserializeRegExpFlags(pos + 16) };
}

function deserializeRegExpFlags(pos) {
    const bits = uint8[pos];
    let text = '';
    if (bits & 1) text += 'g';
    if (bits & 2) text += 'i';
    if (bits & 4) text += 'm';
    if (bits & 8) text += 's';
    if (bits & 16) text += 'u';
    if (bits & 32) text += 'y';
    if (bits & 64) text += 'd';
    if (bits & 128) text += 'v';
    return text;
}

function deserializeBoxStringLiteral(pos) {
    return deserializeStringLiteral(uint32[pos >> 2]);
}

function deserializeBoxTemplateLiteral(pos) {
    return deserializeTemplateLiteral(uint32[pos >> 2]);
}

function deserializeTemplateLiteral(pos) {
    return {
        type: 'TemplateLiteral',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        quasis: deserializeVecTemplateElement(pos),
        expressions: deserializeVecExpression(pos + 32),
    };
}

function deserializeVecTemplateElement(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTemplateElement(pos));
        pos += 48;
    }
    return arr;
}

function deserializeTemplateElement(pos) {
    return {
        type: 'TemplateElement',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        tail: uint8[pos + 40] === 1,
        value: deserializeTemplateElementValue(pos),
    };
}

function deserializeTemplateElementValue(pos) {
    return { raw: deserializeRefStr(pos), cooked: deserializeOptionAtom(pos + 16) };
}

function deserializeOptionAtom(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeRefStr(pos);
}

function deserializeVecExpression(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeExpression(pos));
        pos += 16;
    }
    return arr;
}

function deserializeBoxIdentifierReference(pos) {
    return deserializeIdentifierReference(uint32[pos >> 2]);
}

function deserializeIdentifierReference(pos) {
    return {
        type: 'Identifier',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        name: deserializeRefStr(pos),
    };
}

function deserializeBoxMetaProperty(pos) {
    return deserializeMetaProperty(uint32[pos >> 2]);
}

function deserializeMetaProperty(pos) {
    return {
        type: 'MetaProperty',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        meta: deserializeIdentifierName(pos),
        property: deserializeIdentifierName(pos + 24),
    };
}

function deserializeIdentifierName(pos) {
    return {
        type: 'Identifier',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        name: deserializeRefStr(pos),
    };
}

function deserializeBoxSuper(pos) {
    return deserializeSuper(uint32[pos >> 2]);
}

function deserializeSuper(pos) {
    return { type: 'Super', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxArrayExpression(pos) {
    return deserializeArrayExpression(uint32[pos >> 2]);
}

function deserializeArrayExpression(pos) {
    return {
        type: 'ArrayExpression',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        elements: deserializeVecArrayExpressionElement(pos),
    };
}

function deserializeVecArrayExpressionElement(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeArrayExpressionElement(pos));
        pos += 24;
    }
    return arr;
}

function deserializeArrayExpressionElement(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxSpreadElement(pos + 8);
        case 1:
            return deserializeExpression(pos + 8);
        case 254:
            return null;
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ArrayExpressionElement`);
    }
}

function deserializeBoxSpreadElement(pos) {
    return deserializeSpreadElement(uint32[pos >> 2]);
}

function deserializeSpreadElement(pos) {
    return {
        type: 'SpreadElement',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        argument: deserializeExpression(pos),
    };
}

function deserializeBoxArrowFunctionExpression(pos) {
    return deserializeArrowFunctionExpression(uint32[pos >> 2]);
}

function deserializeArrowFunctionExpression(pos) {
    return {
        type: 'ArrowFunctionExpression',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        expression: uint8[pos + 40] === 1,
        async: uint8[pos + 41] === 1,
        params: deserializeBoxFormalParameters(pos + 24),
        body: deserializeBoxFunctionBody(pos + 32),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 8),
        returnType: deserializeOptionBoxTSTypeAnnotation(pos + 16),
    };
}

function deserializeBoxFormalParameters(pos) {
    return deserializeFormalParameters(uint32[pos >> 2]);
}

function deserializeFormalParameters(pos) {
    const items = deserializeVecFormalParameter(pos),
        rest = deserializeFormalParameterRest(pos + 40);
    if (rest) items.push(rest);

    return {
        type: 'FormalParameters',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        kind: deserializeFormalParameterKind(pos + 48),
        items: items,
    };
}

function deserializeFormalParameterKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'FormalParameter';
        case 1:
            return 'UniqueFormalParameters';
        case 2:
            return 'ArrowFormalParameters';
        case 254:
            return 'Signature';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for FormalParameterKind`);
    }
}

function deserializeVecFormalParameter(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeFormalParameter(pos));
        pos += 80;
    }
    return arr;
}

function deserializeFormalParameter(pos) {
    return {
        type: 'FormalParameter',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        pattern: deserializeBindingPattern(pos + 40),
        accessibility: deserializeOptionTSAccessibility(pos + 72),
        readonly: uint8[pos + 73] === 1,
        override: uint8[pos + 74] === 1,
        decorators: deserializeVecDecorator(pos),
    };
}

function deserializeBindingPattern(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBindingPatternIdentifier(pos + 8);
        case 1:
            return deserializeObjectPattern(pos + 8);
        case 2:
            return deserializeArrayPattern(pos + 8);
        case 254:
            return deserializeAssignmentPattern(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for BindingPattern`);
    }
}

function deserializeBindingPatternIdentifier(pos) {
    const typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 8),
        optional = uint8[pos + 16] === 1;
    pos = uint32[pos >> 2];
    return {
        type: 'Identifier',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        name: deserializeRefStr(pos),
        typeAnnotation: typeAnnotation,
        optional: optional,
    };
}

function deserializeOptionBoxTSTypeAnnotation(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeBoxTSTypeAnnotation(pos);
}

function deserializeBoxTSTypeAnnotation(pos) {
    return deserializeTSTypeAnnotation(uint32[pos >> 2]);
}

function deserializeTSTypeAnnotation(pos) {
    return {
        type: 'TSTypeAnnotation',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        typeAnnotation: deserializeTSType(pos),
    };
}

function deserializeTSType(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxTSAnyKeyword(pos + 8);
        case 1:
            return deserializeBoxTSBigIntKeyword(pos + 8);
        case 2:
            return deserializeBoxTSBooleanKeyword(pos + 8);
        case 3:
            return deserializeBoxTSNeverKeyword(pos + 8);
        case 4:
            return deserializeBoxTSNullKeyword(pos + 8);
        case 5:
            return deserializeBoxTSNumberKeyword(pos + 8);
        case 6:
            return deserializeBoxTSObjectKeyword(pos + 8);
        case 7:
            return deserializeBoxTSStringKeyword(pos + 8);
        case 8:
            return deserializeBoxTSSymbolKeyword(pos + 8);
        case 9:
            return deserializeBoxTSThisType(pos + 8);
        case 10:
            return deserializeBoxTSUndefinedKeyword(pos + 8);
        case 11:
            return deserializeBoxTSUnknownKeyword(pos + 8);
        case 12:
            return deserializeBoxTSVoidKeyword(pos + 8);
        case 13:
            return deserializeBoxTSArrayType(pos + 8);
        case 14:
            return deserializeBoxTSConditionalType(pos + 8);
        case 15:
            return deserializeBoxTSConstructorType(pos + 8);
        case 16:
            return deserializeBoxTSFunctionType(pos + 8);
        case 17:
            return deserializeBoxTSImportType(pos + 8);
        case 18:
            return deserializeBoxTSIndexedAccessType(pos + 8);
        case 19:
            return deserializeBoxTSInferType(pos + 8);
        case 20:
            return deserializeBoxTSIntersectionType(pos + 8);
        case 21:
            return deserializeBoxTSLiteralType(pos + 8);
        case 22:
            return deserializeBoxTSMappedType(pos + 8);
        case 23:
            return deserializeBoxTSNamedTupleMember(pos + 8);
        case 24:
            return deserializeBoxTSQualifiedName(pos + 8);
        case 25:
            return deserializeBoxTSTemplateLiteralType(pos + 8);
        case 26:
            return deserializeBoxTSTupleType(pos + 8);
        case 27:
            return deserializeBoxTSTypeLiteral(pos + 8);
        case 28:
            return deserializeBoxTSTypeOperator(pos + 8);
        case 29:
            return deserializeBoxTSTypePredicate(pos + 8);
        case 30:
            return deserializeBoxTSTypeQuery(pos + 8);
        case 31:
            return deserializeBoxTSTypeReference(pos + 8);
        case 32:
            return deserializeBoxTSUnionType(pos + 8);
        case 33:
            return deserializeBoxJSDocNullableType(pos + 8);
        case 254:
            return deserializeBoxJSDocUnknownType(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSType`);
    }
}

function deserializeBoxTSAnyKeyword(pos) {
    return deserializeTSAnyKeyword(uint32[pos >> 2]);
}

function deserializeTSAnyKeyword(pos) {
    return { type: 'TSAnyKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSBigIntKeyword(pos) {
    return deserializeTSBigIntKeyword(uint32[pos >> 2]);
}

function deserializeTSBigIntKeyword(pos) {
    return { type: 'TSBigIntKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSBooleanKeyword(pos) {
    return deserializeTSBooleanKeyword(uint32[pos >> 2]);
}

function deserializeTSBooleanKeyword(pos) {
    return { type: 'TSBooleanKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSNeverKeyword(pos) {
    return deserializeTSNeverKeyword(uint32[pos >> 2]);
}

function deserializeTSNeverKeyword(pos) {
    return { type: 'TSNeverKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSNullKeyword(pos) {
    return deserializeTSNullKeyword(uint32[pos >> 2]);
}

function deserializeTSNullKeyword(pos) {
    return { type: 'TSNullKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSNumberKeyword(pos) {
    return deserializeTSNumberKeyword(uint32[pos >> 2]);
}

function deserializeTSNumberKeyword(pos) {
    return { type: 'TSNumberKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSObjectKeyword(pos) {
    return deserializeTSObjectKeyword(uint32[pos >> 2]);
}

function deserializeTSObjectKeyword(pos) {
    return { type: 'TSObjectKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSStringKeyword(pos) {
    return deserializeTSStringKeyword(uint32[pos >> 2]);
}

function deserializeTSStringKeyword(pos) {
    return { type: 'TSStringKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSSymbolKeyword(pos) {
    return deserializeTSSymbolKeyword(uint32[pos >> 2]);
}

function deserializeTSSymbolKeyword(pos) {
    return { type: 'TSSymbolKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSThisType(pos) {
    return deserializeTSThisType(uint32[pos >> 2]);
}

function deserializeTSThisType(pos) {
    return { type: 'TSThisType', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSUndefinedKeyword(pos) {
    return deserializeTSUndefinedKeyword(uint32[pos >> 2]);
}

function deserializeTSUndefinedKeyword(pos) {
    return { type: 'TSUndefinedKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSUnknownKeyword(pos) {
    return deserializeTSUnknownKeyword(uint32[pos >> 2]);
}

function deserializeTSUnknownKeyword(pos) {
    return { type: 'TSUnknownKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSVoidKeyword(pos) {
    return deserializeTSVoidKeyword(uint32[pos >> 2]);
}

function deserializeTSVoidKeyword(pos) {
    return { type: 'TSVoidKeyword', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxTSArrayType(pos) {
    return deserializeTSArrayType(uint32[pos >> 2]);
}

function deserializeTSArrayType(pos) {
    return {
        type: 'TSArrayType',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        elementType: deserializeTSType(pos),
    };
}

function deserializeBoxTSConditionalType(pos) {
    return deserializeTSConditionalType(uint32[pos >> 2]);
}

function deserializeTSConditionalType(pos) {
    return {
        type: 'TSConditionalType',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        checkType: deserializeTSType(pos),
        extendsType: deserializeTSType(pos + 16),
        trueType: deserializeTSType(pos + 32),
        falseType: deserializeTSType(pos + 48),
    };
}

function deserializeBoxTSConstructorType(pos) {
    return deserializeTSConstructorType(uint32[pos >> 2]);
}

function deserializeTSConstructorType(pos) {
    return {
        type: 'TSConstructorType',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        abstract: uint8[pos + 32] === 1,
        params: deserializeBoxFormalParameters(pos),
        returnType: deserializeBoxTSTypeAnnotation(pos + 8),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 24),
    };
}

function deserializeOptionBoxTSTypeParameterDeclaration(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeBoxTSTypeParameterDeclaration(pos);
}

function deserializeBoxTSTypeParameterDeclaration(pos) {
    return deserializeTSTypeParameterDeclaration(uint32[pos >> 2]);
}

function deserializeTSTypeParameterDeclaration(pos) {
    return {
        type: 'TSTypeParameterDeclaration',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        params: deserializeVecTSTypeParameter(pos),
    };
}

function deserializeVecTSTypeParameter(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTSTypeParameter(pos));
        pos += 80;
    }
    return arr;
}

function deserializeTSTypeParameter(pos) {
    return {
        type: 'TSTypeParameter',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        name: deserializeBindingIdentifier(pos),
        constraint: deserializeOptionTSType(pos + 32),
        default: deserializeOptionTSType(pos + 48),
        in: uint8[pos + 72] === 1,
        out: uint8[pos + 73] === 1,
        const: uint8[pos + 74] === 1,
    };
}

function deserializeBindingIdentifier(pos) {
    return {
        type: 'Identifier',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        name: deserializeRefStr(pos),
    };
}

function deserializeOptionTSType(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeTSType(pos);
}

function deserializeBoxTSFunctionType(pos) {
    return deserializeTSFunctionType(uint32[pos >> 2]);
}

function deserializeTSFunctionType(pos) {
    return {
        type: 'TSFunctionType',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        thisParam: deserializeOptionTSThisParameter(pos + 24),
        params: deserializeBoxFormalParameters(pos),
        returnType: deserializeBoxTSTypeAnnotation(pos + 8),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 64),
    };
}

function deserializeOptionTSThisParameter(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeTSThisParameter(pos);
}

function deserializeTSThisParameter(pos) {
    return {
        type: 'TSThisParameter',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        this: deserializeIdentifierName(pos),
        typeAnnotation: deserializeOptionBoxTSTypeAnnotation(pos + 32),
    };
}

function deserializeBoxTSImportType(pos) {
    return deserializeTSImportType(uint32[pos >> 2]);
}

function deserializeTSImportType(pos) {
    return {
        type: 'TSImportType',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        argument: deserializeTSType(pos),
        qualifier: deserializeOptionTSTypeName(pos + 24),
        attributes: deserializeOptionTSImportAttributes(pos + 40),
        typeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 80),
    };
}

function deserializeOptionTSTypeName(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeTSTypeName(pos);
}

function deserializeTSTypeName(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxIdentifierReference(pos + 8);
        case 254:
            return deserializeBoxTSQualifiedName(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSTypeName`);
    }
}

function deserializeBoxTSQualifiedName(pos) {
    return deserializeTSQualifiedName(uint32[pos >> 2]);
}

function deserializeTSQualifiedName(pos) {
    return {
        type: 'TSQualifiedName',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        left: deserializeTSTypeName(pos),
        right: deserializeIdentifierName(pos + 16),
    };
}

function deserializeOptionTSImportAttributes(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeTSImportAttributes(pos);
}

function deserializeTSImportAttributes(pos) {
    return {
        type: 'TSImportAttributes',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        elements: deserializeVecTSImportAttribute(pos),
    };
}

function deserializeVecTSImportAttribute(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTSImportAttribute(pos));
        pos += 56;
    }
    return arr;
}

function deserializeTSImportAttribute(pos) {
    return {
        type: 'TSImportAttribute',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        name: deserializeTSImportAttributeName(pos),
        value: deserializeExpression(pos + 32),
    };
}

function deserializeTSImportAttributeName(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeIdentifierName(pos + 8);
        case 254:
            return deserializeStringLiteral(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSImportAttributeName`);
    }
}

function deserializeOptionBoxTSTypeParameterInstantiation(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeBoxTSTypeParameterInstantiation(pos);
}

function deserializeBoxTSTypeParameterInstantiation(pos) {
    return deserializeTSTypeParameterInstantiation(uint32[pos >> 2]);
}

function deserializeTSTypeParameterInstantiation(pos) {
    return {
        type: 'TSTypeParameterInstantiation',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        params: deserializeVecTSType(pos),
    };
}

function deserializeVecTSType(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTSType(pos));
        pos += 16;
    }
    return arr;
}

function deserializeBoxTSIndexedAccessType(pos) {
    return deserializeTSIndexedAccessType(uint32[pos >> 2]);
}

function deserializeTSIndexedAccessType(pos) {
    return {
        type: 'TSIndexedAccessType',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        objectType: deserializeTSType(pos),
        indexType: deserializeTSType(pos + 16),
    };
}

function deserializeBoxTSInferType(pos) {
    return deserializeTSInferType(uint32[pos >> 2]);
}

function deserializeTSInferType(pos) {
    return {
        type: 'TSInferType',
        start: uint32[(pos + 8) >> 2],
        end: uint32[(pos + 12) >> 2],
        typeParameter: deserializeBoxTSTypeParameter(pos),
    };
}

function deserializeBoxTSTypeParameter(pos) {
    return deserializeTSTypeParameter(uint32[pos >> 2]);
}

function deserializeBoxTSIntersectionType(pos) {
    return deserializeTSIntersectionType(uint32[pos >> 2]);
}

function deserializeTSIntersectionType(pos) {
    return {
        type: 'TSIntersectionType',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        types: deserializeVecTSType(pos),
    };
}

function deserializeBoxTSLiteralType(pos) {
    return deserializeTSLiteralType(uint32[pos >> 2]);
}

function deserializeTSLiteralType(pos) {
    return {
        type: 'TSLiteralType',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        literal: deserializeTSLiteral(pos),
    };
}

function deserializeTSLiteral(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxBooleanLiteral(pos + 8);
        case 1:
            return deserializeBoxNullLiteral(pos + 8);
        case 2:
            return deserializeBoxNumericLiteral(pos + 8);
        case 3:
            return deserializeBoxBigIntLiteral(pos + 8);
        case 4:
            return deserializeBoxRegExpLiteral(pos + 8);
        case 5:
            return deserializeBoxStringLiteral(pos + 8);
        case 6:
            return deserializeBoxTemplateLiteral(pos + 8);
        case 254:
            return deserializeBoxUnaryExpression(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSLiteral`);
    }
}

function deserializeBoxUnaryExpression(pos) {
    return deserializeUnaryExpression(uint32[pos >> 2]);
}

function deserializeUnaryExpression(pos) {
    return {
        type: 'UnaryExpression',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        operator: deserializeUnaryOperator(pos + 24),
        argument: deserializeExpression(pos),
    };
}

function deserializeUnaryOperator(pos) {
    switch (uint8[pos]) {
        case 0:
            return '-';
        case 1:
            return '+';
        case 2:
            return '!';
        case 3:
            return '~';
        case 4:
            return 'typeof';
        case 5:
            return 'void';
        case 254:
            return 'delete';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for UnaryOperator`);
    }
}

function deserializeBoxTSMappedType(pos) {
    return deserializeTSMappedType(uint32[pos >> 2]);
}

function deserializeTSMappedType(pos) {
    return {
        type: 'TSMappedType',
        start: uint32[(pos + 8) >> 2],
        end: uint32[(pos + 12) >> 2],
        typeParameter: deserializeBoxTSTypeParameter(pos),
        nameType: deserializeOptionTSType(pos + 16),
        typeAnnotation: deserializeOptionTSType(pos + 32),
        optional: deserializeTSMappedTypeModifierOperator(pos + 48),
        readonly: deserializeTSMappedTypeModifierOperator(pos + 49),
    };
}

function deserializeTSMappedTypeModifierOperator(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'true';
        case 1:
            return '+';
        case 2:
            return '-';
        case 254:
            return 'none';
        default:
            throw new Error(
                `Unexpected discriminant ${uint8[pos]} for TSMappedTypeModifierOperator`,
            );
    }
}

function deserializeBoxTSNamedTupleMember(pos) {
    return deserializeTSNamedTupleMember(uint32[pos >> 2]);
}

function deserializeTSNamedTupleMember(pos) {
    return {
        type: 'TSNamedTupleMember',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        elementType: deserializeTSType(pos),
        label: deserializeIdentifierName(pos + 16),
        optional: uint8[pos + 48] === 1,
    };
}

function deserializeBoxTSTemplateLiteralType(pos) {
    return deserializeTSTemplateLiteralType(uint32[pos >> 2]);
}

function deserializeTSTemplateLiteralType(pos) {
    return {
        type: 'TSTemplateLiteralType',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        quasis: deserializeVecTemplateElement(pos),
        types: deserializeVecTSType(pos + 32),
    };
}

function deserializeBoxTSTupleType(pos) {
    return deserializeTSTupleType(uint32[pos >> 2]);
}

function deserializeTSTupleType(pos) {
    return {
        type: 'TSTupleType',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        elementTypes: deserializeVecTSTupleElement(pos),
    };
}

function deserializeVecTSTupleElement(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTSTupleElement(pos));
        pos += 24;
    }
    return arr;
}

function deserializeTSTupleElement(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeTSType(pos + 8);
        case 1:
            return deserializeBoxTSOptionalType(pos + 8);
        case 2:
            return deserializeBoxTSRestType(pos + 8);
        case 254:
            return deserializeBoxTSNamedTupleMember(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSTupleElement`);
    }
}

function deserializeBoxTSOptionalType(pos) {
    return deserializeTSOptionalType(uint32[pos >> 2]);
}

function deserializeTSOptionalType(pos) {
    return {
        type: 'TSOptionalType',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        typeAnnotation: deserializeTSType(pos),
    };
}

function deserializeBoxTSRestType(pos) {
    return deserializeTSRestType(uint32[pos >> 2]);
}

function deserializeTSRestType(pos) {
    return {
        type: 'TSRestType',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        typeAnnotation: deserializeTSType(pos),
    };
}

function deserializeBoxTSTypeLiteral(pos) {
    return deserializeTSTypeLiteral(uint32[pos >> 2]);
}

function deserializeTSTypeLiteral(pos) {
    return {
        type: 'TSTypeLiteral',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        members: deserializeVecTSSignature(pos),
    };
}

function deserializeVecTSSignature(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTSSignature(pos));
        pos += 16;
    }
    return arr;
}

function deserializeTSSignature(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxTSIndexSignature(pos + 8);
        case 1:
            return deserializeBoxTSPropertySignature(pos + 8);
        case 2:
            return deserializeBoxTSCallSignatureDeclaration(pos + 8);
        case 3:
            return deserializeBoxTSConstructSignatureDeclaration(pos + 8);
        case 254:
            return deserializeBoxTSMethodSignature(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSSignature`);
    }
}

function deserializeBoxTSIndexSignature(pos) {
    return deserializeTSIndexSignature(uint32[pos >> 2]);
}

function deserializeTSIndexSignature(pos) {
    return {
        type: 'TSIndexSignature',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        parameters: deserializeVecTSIndexSignatureName(pos),
        typeAnnotation: deserializeBoxTSTypeAnnotation(pos + 32),
        readonly: uint8[pos + 48] === 1,
    };
}

function deserializeVecTSIndexSignatureName(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTSIndexSignatureName(pos));
        pos += 32;
    }
    return arr;
}

function deserializeTSIndexSignatureName(pos) {
    return {
        type: 'Identifier',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        name: deserializeRefStr(pos),
        typeAnnotation: deserializeBoxTSTypeAnnotation(pos + 16),
    };
}

function deserializeBoxTSPropertySignature(pos) {
    return deserializeTSPropertySignature(uint32[pos >> 2]);
}

function deserializeTSPropertySignature(pos) {
    return {
        type: 'TSPropertySignature',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        computed: uint8[pos + 40] === 1,
        optional: uint8[pos + 41] === 1,
        readonly: uint8[pos + 42] === 1,
        key: deserializePropertyKey(pos + 16),
        typeAnnotation: deserializeOptionBoxTSTypeAnnotation(pos + 8),
    };
}

function deserializePropertyKey(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxIdentifierName(pos + 8);
        case 1:
            return deserializeBoxPrivateIdentifier(pos + 8);
        case 254:
            return deserializeExpression(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for PropertyKey`);
    }
}

function deserializeBoxIdentifierName(pos) {
    return deserializeIdentifierName(uint32[pos >> 2]);
}

function deserializeBoxPrivateIdentifier(pos) {
    return deserializePrivateIdentifier(uint32[pos >> 2]);
}

function deserializePrivateIdentifier(pos) {
    return {
        type: 'PrivateIdentifier',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        name: deserializeRefStr(pos),
    };
}

function deserializeBoxTSCallSignatureDeclaration(pos) {
    return deserializeTSCallSignatureDeclaration(uint32[pos >> 2]);
}

function deserializeTSCallSignatureDeclaration(pos) {
    return {
        type: 'TSCallSignatureDeclaration',
        start: uint32[(pos + 8) >> 2],
        end: uint32[(pos + 12) >> 2],
        thisParam: deserializeOptionTSThisParameter(pos + 16),
        params: deserializeBoxFormalParameters(pos),
        returnType: deserializeOptionBoxTSTypeAnnotation(pos + 56),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 64),
    };
}

function deserializeBoxTSConstructSignatureDeclaration(pos) {
    return deserializeTSConstructSignatureDeclaration(uint32[pos >> 2]);
}

function deserializeTSConstructSignatureDeclaration(pos) {
    return {
        type: 'TSConstructSignatureDeclaration',
        start: uint32[(pos + 8) >> 2],
        end: uint32[(pos + 12) >> 2],
        params: deserializeBoxFormalParameters(pos),
        returnType: deserializeOptionBoxTSTypeAnnotation(pos + 16),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 24),
    };
}

function deserializeBoxTSMethodSignature(pos) {
    return deserializeTSMethodSignature(uint32[pos >> 2]);
}

function deserializeTSMethodSignature(pos) {
    return {
        type: 'TSMethodSignature',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        key: deserializePropertyKey(pos + 64),
        computed: uint8[pos + 97] === 1,
        optional: uint8[pos + 98] === 1,
        kind: deserializeTSMethodSignatureKind(pos + 96),
        thisParam: deserializeOptionTSThisParameter(pos + 8),
        params: deserializeBoxFormalParameters(pos + 88),
        returnType: deserializeOptionBoxTSTypeAnnotation(pos + 48),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 56),
    };
}

function deserializeTSMethodSignatureKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'method';
        case 1:
            return 'get';
        case 254:
            return 'set';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSMethodSignatureKind`);
    }
}

function deserializeBoxTSTypeOperator(pos) {
    return deserializeTSTypeOperator(uint32[pos >> 2]);
}

function deserializeTSTypeOperator(pos) {
    return {
        type: 'TSTypeOperator',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        operator: deserializeTSTypeOperatorOperator(pos + 24),
        typeAnnotation: deserializeTSType(pos),
    };
}

function deserializeTSTypeOperatorOperator(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'keyof';
        case 1:
            return 'unique';
        case 254:
            return 'readonly';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSTypeOperatorOperator`);
    }
}

function deserializeBoxTSTypePredicate(pos) {
    return deserializeTSTypePredicate(uint32[pos >> 2]);
}

function deserializeTSTypePredicate(pos) {
    return {
        type: 'TSTypePredicate',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        parameterName: deserializeTSTypePredicateName(pos),
        asserts: uint8[pos + 32] === 1,
        typeAnnotation: deserializeOptionBoxTSTypeAnnotation(pos + 24),
    };
}

function deserializeTSTypePredicateName(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxIdentifierName(pos + 8);
        case 254:
            return deserializeTSThisType(pos + 4);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSTypePredicateName`);
    }
}

function deserializeBoxTSTypeQuery(pos) {
    return deserializeTSTypeQuery(uint32[pos >> 2]);
}

function deserializeTSTypeQuery(pos) {
    return {
        type: 'TSTypeQuery',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        exprName: deserializeTSTypeQueryExprName(pos),
        typeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 32),
    };
}

function deserializeTSTypeQueryExprName(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeTSTypeName(pos + 8);
        case 254:
            return deserializeBoxTSImportType(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSTypeQueryExprName`);
    }
}

function deserializeBoxTSTypeReference(pos) {
    return deserializeTSTypeReference(uint32[pos >> 2]);
}

function deserializeTSTypeReference(pos) {
    return {
        type: 'TSTypeReference',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        typeName: deserializeTSTypeName(pos),
        typeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 24),
    };
}

function deserializeBoxTSUnionType(pos) {
    return deserializeTSUnionType(uint32[pos >> 2]);
}

function deserializeTSUnionType(pos) {
    return {
        type: 'TSUnionType',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        types: deserializeVecTSType(pos),
    };
}

function deserializeBoxJSDocNullableType(pos) {
    return deserializeJSDocNullableType(uint32[pos >> 2]);
}

function deserializeJSDocNullableType(pos) {
    return {
        type: 'JSDocNullableType',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        typeAnnotation: deserializeTSType(pos),
        postfix: uint8[pos + 24] === 1,
    };
}

function deserializeBoxJSDocUnknownType(pos) {
    return deserializeJSDocUnknownType(uint32[pos >> 2]);
}

function deserializeJSDocUnknownType(pos) {
    return { type: 'JSDocUnknownType', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeObjectPattern(pos) {
    const typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 8),
        optional = uint8[pos + 16] === 1;
    pos = uint32[pos >> 2];
    const properties = deserializeVecBindingProperty(pos),
        rest = deserializeOptionBoxBindingRestElement(pos + 40);
    if (rest) properties.push(rest);

    return {
        type: 'ObjectPattern',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        properties: properties,
        typeAnnotation: typeAnnotation,
        optional: optional,
    };
}

function deserializeVecBindingProperty(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeBindingProperty(pos));
        pos += 72;
    }
    return arr;
}

function deserializeBindingProperty(pos) {
    return {
        type: 'BindingProperty',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        key: deserializePropertyKey(pos + 8),
        value: deserializeBindingPattern(pos + 32),
        shorthand: uint8[pos + 64] === 1,
        computed: uint8[pos + 65] === 1,
    };
}

function deserializeOptionBoxBindingRestElement(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeBoxBindingRestElement(pos);
}

function deserializeBoxBindingRestElement(pos) {
    return deserializeBindingRestElement(uint32[pos >> 2]);
}

function deserializeBindingRestElement(pos) {
    return {
        type: 'RestElement',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        argument: deserializeBindingPattern(pos + 8),
    };
}

function deserializeArrayPattern(pos) {
    const typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 8),
        optional = uint8[pos + 16] === 1;
    pos = uint32[pos >> 2];
    const elements = deserializeVecOptionBindingPattern(pos),
        rest = deserializeOptionBoxBindingRestElement(pos + 40);
    if (rest) elements.push(rest);

    return {
        type: 'ArrayPattern',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        elements: elements,
        typeAnnotation: typeAnnotation,
        optional: optional,
    };
}

function deserializeVecOptionBindingPattern(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeOptionBindingPattern(pos));
        pos += 32;
    }
    return arr;
}

function deserializeOptionBindingPattern(pos) {
    if (uint8[pos + 24] === 2) return null;
    return deserializeBindingPattern(pos);
}

function deserializeAssignmentPattern(pos) {
    const typeAnnotation = deserializeOptionBoxTSTypeAnnotation(pos + 8),
        optional = uint8[pos + 16] === 1;
    pos = uint32[pos >> 2];
    return {
        type: 'AssignmentPattern',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        left: deserializeBindingPattern(pos + 24),
        right: deserializeExpression(pos),
        typeAnnotation: typeAnnotation,
        optional: optional,
    };
}

function deserializeOptionTSAccessibility(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeTSAccessibility(pos);
}

function deserializeTSAccessibility(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'private';
        case 1:
            return 'protected';
        case 254:
            return 'public';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSAccessibility`);
    }
}

function deserializeVecDecorator(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeDecorator(pos));
        pos += 24;
    }
    return arr;
}

function deserializeDecorator(pos) {
    return {
        type: 'Decorator',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        expression: deserializeExpression(pos),
    };
}

function deserializeFormalParameterRest(pos) {
    let rest = deserializeOptionBoxBindingRestElement(pos);
    if (!rest) return null;
    const { typeAnnotation, optional, ...argument } = rest.argument;
    rest.argument = argument;
    rest.typeAnnotation = typeAnnotation;
    rest.optional = optional;
    return rest;
}

function deserializeBoxFunctionBody(pos) {
    return deserializeFunctionBody(uint32[pos >> 2]);
}

function deserializeFunctionBody(pos) {
    return {
        type: 'FunctionBody',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        directives: deserializeVecDirective(pos),
        statements: deserializeVecStatement(pos + 32),
    };
}

function deserializeBoxAssignmentExpression(pos) {
    return deserializeAssignmentExpression(uint32[pos >> 2]);
}

function deserializeAssignmentExpression(pos) {
    return {
        type: 'AssignmentExpression',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        operator: deserializeAssignmentOperator(pos + 48),
        left: deserializeAssignmentTarget(pos),
        right: deserializeExpression(pos + 24),
    };
}

function deserializeAssignmentOperator(pos) {
    switch (uint8[pos]) {
        case 0:
            return '=';
        case 1:
            return '+=';
        case 2:
            return '-=';
        case 3:
            return '*=';
        case 4:
            return '/=';
        case 5:
            return '%=';
        case 6:
            return '<<=';
        case 7:
            return '>>=';
        case 8:
            return '>>>=';
        case 9:
            return '|=';
        case 10:
            return '^=';
        case 11:
            return '&=';
        case 12:
            return '&&=';
        case 13:
            return '||=';
        case 14:
            return '??=';
        case 254:
            return '**=';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for AssignmentOperator`);
    }
}

function deserializeAssignmentTarget(pos) {
    switch (uint8[pos]) {
        case 1:
            return deserializeSimpleAssignmentTarget(pos + 8);
        case 254:
            return deserializeAssignmentTargetPattern(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for AssignmentTarget`);
    }
}

function deserializeSimpleAssignmentTarget(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxIdentifierReference(pos + 8);
        case 1:
            return deserializeBoxMemberExpression(pos + 8);
        case 2:
            return deserializeBoxTSAsExpression(pos + 8);
        case 3:
            return deserializeBoxTSSatisfiesExpression(pos + 8);
        case 4:
            return deserializeBoxTSNonNullExpression(pos + 8);
        case 254:
            return deserializeBoxTSTypeAssertion(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for SimpleAssignmentTarget`);
    }
}

function deserializeBoxMemberExpression(pos) {
    return deserializeMemberExpression(uint32[pos >> 2]);
}

function deserializeMemberExpression(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeComputedMemberExpression(pos + 8);
        case 1:
            return deserializeStaticMemberExpression(pos + 8);
        case 254:
            return deserializePrivateFieldExpression(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for MemberExpression`);
    }
}

function deserializeComputedMemberExpression(pos) {
    return {
        type: 'ComputedMemberExpression',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        object: deserializeExpression(pos),
        expression: deserializeExpression(pos + 16),
        optional: uint8[pos + 40] === 1,
    };
}

function deserializeStaticMemberExpression(pos) {
    return {
        type: 'StaticMemberExpression',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        object: deserializeExpression(pos),
        property: deserializeIdentifierName(pos + 16),
        optional: uint8[pos + 48] === 1,
    };
}

function deserializePrivateFieldExpression(pos) {
    return {
        type: 'PrivateFieldExpression',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        object: deserializeExpression(pos),
        field: deserializePrivateIdentifier(pos + 16),
        optional: uint8[pos + 48] === 1,
    };
}

function deserializeBoxTSAsExpression(pos) {
    return deserializeTSAsExpression(uint32[pos >> 2]);
}

function deserializeTSAsExpression(pos) {
    return {
        type: 'TSAsExpression',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        expression: deserializeExpression(pos),
        typeAnnotation: deserializeTSType(pos + 16),
    };
}

function deserializeBoxTSSatisfiesExpression(pos) {
    return deserializeTSSatisfiesExpression(uint32[pos >> 2]);
}

function deserializeTSSatisfiesExpression(pos) {
    return {
        type: 'TSSatisfiesExpression',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        expression: deserializeExpression(pos),
        typeAnnotation: deserializeTSType(pos + 16),
    };
}

function deserializeBoxTSNonNullExpression(pos) {
    return deserializeTSNonNullExpression(uint32[pos >> 2]);
}

function deserializeTSNonNullExpression(pos) {
    return {
        type: 'TSNonNullExpression',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        expression: deserializeExpression(pos),
    };
}

function deserializeBoxTSTypeAssertion(pos) {
    return deserializeTSTypeAssertion(uint32[pos >> 2]);
}

function deserializeTSTypeAssertion(pos) {
    return {
        type: 'TSTypeAssertion',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        expression: deserializeExpression(pos),
        typeAnnotation: deserializeTSType(pos + 16),
    };
}

function deserializeAssignmentTargetPattern(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxArrayAssignmentTarget(pos + 8);
        case 254:
            return deserializeBoxObjectAssignmentTarget(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for AssignmentTargetPattern`);
    }
}

function deserializeBoxArrayAssignmentTarget(pos) {
    return deserializeArrayAssignmentTarget(uint32[pos >> 2]);
}

function deserializeArrayAssignmentTarget(pos) {
    const elements = deserializeVecOptionAssignmentTargetMaybeDefault(pos),
        rest = deserializeOptionAssignmentTargetRest(pos + 32);
    if (rest) elements.push(rest);

    return {
        type: 'ArrayAssignmentTarget',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        elements: elements,
    };
}

function deserializeVecOptionAssignmentTargetMaybeDefault(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeOptionAssignmentTargetMaybeDefault(pos));
        pos += 24;
    }
    return arr;
}

function deserializeOptionAssignmentTargetMaybeDefault(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeAssignmentTargetMaybeDefault(pos);
}

function deserializeAssignmentTargetMaybeDefault(pos) {
    switch (uint8[pos]) {
        case 1:
            return deserializeSimpleAssignmentTarget(pos + 8);
        case 254:
            return deserializeAssignmentTargetPattern(pos + 8);
        case 0:
            return deserializeBoxAssignmentTargetWithDefault(pos + 8);
        default:
            throw new Error(
                `Unexpected discriminant ${uint8[pos]} for AssignmentTargetMaybeDefault`,
            );
    }
}

function deserializeBoxAssignmentTargetWithDefault(pos) {
    return deserializeAssignmentTargetWithDefault(uint32[pos >> 2]);
}

function deserializeAssignmentTargetWithDefault(pos) {
    return {
        type: 'AssignmentTargetWithDefault',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        binding: deserializeAssignmentTarget(pos),
        init: deserializeExpression(pos + 24),
    };
}

function deserializeOptionAssignmentTargetRest(pos) {
    if (uint8[pos] === 0) return null;
    return deserializeAssignmentTargetRest(pos);
}

function deserializeAssignmentTargetRest(pos) {
    return {
        type: 'RestElement',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        argument: deserializeAssignmentTarget(pos),
    };
}

function deserializeBoxObjectAssignmentTarget(pos) {
    return deserializeObjectAssignmentTarget(uint32[pos >> 2]);
}

function deserializeObjectAssignmentTarget(pos) {
    const properties = deserializeVecAssignmentTargetProperty(pos),
        rest = deserializeOptionAssignmentTargetRest(pos + 32);
    if (rest) properties.push(rest);

    return {
        type: 'ObjectAssignmentTarget',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        properties: properties,
    };
}

function deserializeVecAssignmentTargetProperty(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeAssignmentTargetProperty(pos));
        pos += 16;
    }
    return arr;
}

function deserializeAssignmentTargetProperty(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxAssignmentTargetPropertyIdentifier(pos + 8);
        case 254:
            return deserializeBoxAssignmentTargetPropertyProperty(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for AssignmentTargetProperty`);
    }
}

function deserializeBoxAssignmentTargetPropertyIdentifier(pos) {
    return deserializeAssignmentTargetPropertyIdentifier(uint32[pos >> 2]);
}

function deserializeAssignmentTargetPropertyIdentifier(pos) {
    return {
        type: 'AssignmentTargetPropertyIdentifier',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        binding: deserializeIdentifierReference(pos),
        init: deserializeOptionExpression(pos + 48),
    };
}

function deserializeOptionExpression(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeExpression(pos);
}

function deserializeBoxAssignmentTargetPropertyProperty(pos) {
    return deserializeAssignmentTargetPropertyProperty(uint32[pos >> 2]);
}

function deserializeAssignmentTargetPropertyProperty(pos) {
    return {
        type: 'AssignmentTargetPropertyProperty',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        name: deserializePropertyKey(pos),
        binding: deserializeAssignmentTargetMaybeDefault(pos + 24),
    };
}

function deserializeBoxAwaitExpression(pos) {
    return deserializeAwaitExpression(uint32[pos >> 2]);
}

function deserializeAwaitExpression(pos) {
    return {
        type: 'AwaitExpression',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        argument: deserializeExpression(pos),
    };
}

function deserializeBoxBinaryExpression(pos) {
    return deserializeBinaryExpression(uint32[pos >> 2]);
}

function deserializeBinaryExpression(pos) {
    return {
        type: 'BinaryExpression',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        left: deserializeExpression(pos),
        operator: deserializeBinaryOperator(pos + 40),
        right: deserializeExpression(pos + 16),
    };
}

function deserializeBinaryOperator(pos) {
    switch (uint8[pos]) {
        case 0:
            return '==';
        case 1:
            return '!=';
        case 2:
            return '===';
        case 3:
            return '!==';
        case 4:
            return '<';
        case 5:
            return '<=';
        case 6:
            return '>';
        case 7:
            return '>=';
        case 8:
            return '<<';
        case 9:
            return '>>';
        case 10:
            return '>>>';
        case 11:
            return '+';
        case 12:
            return '-';
        case 13:
            return '*';
        case 14:
            return '/';
        case 15:
            return '%';
        case 16:
            return '|';
        case 17:
            return '^';
        case 18:
            return '&';
        case 19:
            return 'in';
        case 20:
            return 'instanceof';
        case 254:
            return '**';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for BinaryOperator`);
    }
}

function deserializeBoxCallExpression(pos) {
    return deserializeCallExpression(uint32[pos >> 2]);
}

function deserializeCallExpression(pos) {
    return {
        type: 'CallExpression',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        callee: deserializeExpression(pos),
        arguments: deserializeVecArgument(pos + 16),
        optional: uint8[pos + 64] === 1,
        typeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 56),
    };
}

function deserializeVecArgument(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeArgument(pos));
        pos += 24;
    }
    return arr;
}

function deserializeArgument(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxSpreadElement(pos + 8);
        case 254:
            return deserializeExpression(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for Argument`);
    }
}

function deserializeBoxChainExpression(pos) {
    return deserializeChainExpression(uint32[pos >> 2]);
}

function deserializeChainExpression(pos) {
    return {
        type: 'ChainExpression',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        expression: deserializeChainElement(pos),
    };
}

function deserializeChainElement(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxCallExpression(pos + 8);
        case 254:
            return deserializeBoxMemberExpression(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ChainElement`);
    }
}

function deserializeBoxClass(pos) {
    return deserializeClass(uint32[pos >> 2]);
}

function deserializeClass(pos) {
    return {
        type: deserializeClassType(pos + 176),
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        id: deserializeOptionBindingIdentifier(pos + 48),
        superClass: deserializeOptionExpression(pos + 80),
        body: deserializeBoxClassBody(pos),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 96),
        superTypeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 104),
        implements: deserializeOptionVecTSClassImplements(pos + 112),
        decorators: deserializeVecDecorator(pos + 8),
        modifiers: deserializeOptionVecModifier(pos + 144),
    };
}

function deserializeClassType(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'ClassDeclaration';
        case 254:
            return 'ClassExpression';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ClassType`);
    }
}

function deserializeOptionBindingIdentifier(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeBindingIdentifier(pos);
}

function deserializeBoxClassBody(pos) {
    return deserializeClassBody(uint32[pos >> 2]);
}

function deserializeClassBody(pos) {
    return {
        type: 'ClassBody',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        body: deserializeVecClassElement(pos),
    };
}

function deserializeVecClassElement(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeClassElement(pos));
        pos += 16;
    }
    return arr;
}

function deserializeClassElement(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxStaticBlock(pos + 8);
        case 1:
            return deserializeBoxMethodDefinition(pos + 8);
        case 2:
            return deserializeBoxPropertyDefinition(pos + 8);
        case 3:
            return deserializeBoxAccessorProperty(pos + 8);
        case 254:
            return deserializeBoxTSIndexSignature(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ClassElement`);
    }
}

function deserializeBoxStaticBlock(pos) {
    return deserializeStaticBlock(uint32[pos >> 2]);
}

function deserializeStaticBlock(pos) {
    return {
        type: 'StaticBlock',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        body: deserializeVecStatement(pos),
    };
}

function deserializeBoxMethodDefinition(pos) {
    return deserializeMethodDefinition(uint32[pos >> 2]);
}

function deserializeMethodDefinition(pos) {
    return {
        type: deserializeMethodDefinitionType(pos + 73),
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        key: deserializePropertyKey(pos + 40),
        value: deserializeBoxFunction(pos + 64),
        kind: deserializeMethodDefinitionKind(pos + 74),
        computed: uint8[pos + 75] === 1,
        static: uint8[pos + 76] === 1,
        override: uint8[pos + 77] === 1,
        optional: uint8[pos + 78] === 1,
        accessibility: deserializeOptionTSAccessibility(pos + 72),
        decorators: deserializeVecDecorator(pos),
    };
}

function deserializeMethodDefinitionType(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'MethodDefinition';
        case 254:
            return 'TSAbstractMethodDefinition';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for MethodDefinitionType`);
    }
}

function deserializeBoxFunction(pos) {
    return deserializeFunction(uint32[pos >> 2]);
}

function deserializeFunction(pos) {
    return {
        type: deserializeFunctionType(pos + 144),
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        id: deserializeOptionBindingIdentifier(pos),
        generator: uint8[pos + 145] === 1,
        async: uint8[pos + 146] === 1,
        thisParam: deserializeOptionTSThisParameter(pos + 72),
        params: deserializeBoxFormalParameters(pos + 136),
        body: deserializeOptionBoxFunctionBody(pos + 112),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 120),
        returnType: deserializeOptionBoxTSTypeAnnotation(pos + 128),
        modifiers: deserializeOptionVecModifier(pos + 32),
    };
}

function deserializeFunctionType(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'FunctionDeclaration';
        case 1:
            return 'FunctionExpression';
        case 2:
            return 'TSDeclareFunction';
        case 254:
            return 'TSEmptyBodyFunctionExpression';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for FunctionType`);
    }
}

function deserializeOptionBoxFunctionBody(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeBoxFunctionBody(pos);
}

function deserializeOptionVecModifier(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeVecModifier(pos);
}

function deserializeVecModifier(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeModifier(pos));
        pos += 12;
    }
    return arr;
}

function deserializeModifier(pos) {
    return {
        type: 'Modifier',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        kind: deserializeModifierKind(pos + 8),
    };
}

function deserializeModifierKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'abstract';
        case 1:
            return 'accessor';
        case 2:
            return 'async';
        case 3:
            return 'const';
        case 4:
            return 'declare';
        case 5:
            return 'default';
        case 6:
            return 'export';
        case 7:
            return 'in';
        case 8:
            return 'public';
        case 9:
            return 'private';
        case 10:
            return 'protected';
        case 11:
            return 'readonly';
        case 12:
            return 'static';
        case 13:
            return 'out';
        case 254:
            return 'override';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ModifierKind`);
    }
}

function deserializeMethodDefinitionKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'constructor';
        case 1:
            return 'method';
        case 2:
            return 'get';
        case 254:
            return 'set';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for MethodDefinitionKind`);
    }
}

function deserializeBoxPropertyDefinition(pos) {
    return deserializePropertyDefinition(uint32[pos >> 2]);
}

function deserializePropertyDefinition(pos) {
    return {
        type: deserializePropertyDefinitionType(pos + 89),
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        key: deserializePropertyKey(pos + 64),
        value: deserializeOptionExpression(pos + 32),
        computed: uint8[pos + 90] === 1,
        static: uint8[pos + 91] === 1,
        declare: uint8[pos + 92] === 1,
        override: uint8[pos + 93] === 1,
        optional: uint8[pos + 94] === 1,
        definite: uint8[pos + 95] === 1,
        readonly: uint8[pos + 96] === 1,
        typeAnnotation: deserializeOptionBoxTSTypeAnnotation(pos + 56),
        accessibility: deserializeOptionTSAccessibility(pos + 88),
        decorators: deserializeVecDecorator(pos),
    };
}

function deserializePropertyDefinitionType(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'PropertyDefinition';
        case 254:
            return 'TSAbstractPropertyDefinition';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for PropertyDefinitionType`);
    }
}

function deserializeBoxAccessorProperty(pos) {
    return deserializeAccessorProperty(uint32[pos >> 2]);
}

function deserializeAccessorProperty(pos) {
    return {
        type: 'AccessorProperty',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        key: deserializePropertyKey(pos + 56),
        value: deserializeOptionExpression(pos + 32),
        computed: uint8[pos + 80] === 1,
        static: uint8[pos + 81] === 1,
        decorators: deserializeVecDecorator(pos),
    };
}

function deserializeOptionVecTSClassImplements(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeVecTSClassImplements(pos);
}

function deserializeVecTSClassImplements(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTSClassImplements(pos));
        pos += 32;
    }
    return arr;
}

function deserializeTSClassImplements(pos) {
    return {
        type: 'TSClassImplements',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        expression: deserializeTSTypeName(pos),
        typeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 24),
    };
}

function deserializeBoxConditionalExpression(pos) {
    return deserializeConditionalExpression(uint32[pos >> 2]);
}

function deserializeConditionalExpression(pos) {
    return {
        type: 'ConditionalExpression',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        test: deserializeExpression(pos),
        consequent: deserializeExpression(pos + 16),
        alternate: deserializeExpression(pos + 32),
    };
}

function deserializeBoxImportExpression(pos) {
    return deserializeImportExpression(uint32[pos >> 2]);
}

function deserializeImportExpression(pos) {
    return {
        type: 'ImportExpression',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        source: deserializeExpression(pos),
        arguments: deserializeVecExpression(pos + 16),
    };
}

function deserializeBoxLogicalExpression(pos) {
    return deserializeLogicalExpression(uint32[pos >> 2]);
}

function deserializeLogicalExpression(pos) {
    return {
        type: 'LogicalExpression',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        left: deserializeExpression(pos),
        operator: deserializeLogicalOperator(pos + 40),
        right: deserializeExpression(pos + 16),
    };
}

function deserializeLogicalOperator(pos) {
    switch (uint8[pos]) {
        case 0:
            return '||';
        case 1:
            return '&&';
        case 254:
            return '??';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for LogicalOperator`);
    }
}

function deserializeBoxNewExpression(pos) {
    return deserializeNewExpression(uint32[pos >> 2]);
}

function deserializeNewExpression(pos) {
    return {
        type: 'NewExpression',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        callee: deserializeExpression(pos),
        arguments: deserializeVecArgument(pos + 16),
        typeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 56),
    };
}

function deserializeBoxObjectExpression(pos) {
    return deserializeObjectExpression(uint32[pos >> 2]);
}

function deserializeObjectExpression(pos) {
    return {
        type: 'ObjectExpression',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        properties: deserializeVecObjectPropertyKind(pos),
    };
}

function deserializeVecObjectPropertyKind(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeObjectPropertyKind(pos));
        pos += 16;
    }
    return arr;
}

function deserializeObjectPropertyKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxObjectProperty(pos + 8);
        case 254:
            return deserializeBoxSpreadElement(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ObjectPropertyKind`);
    }
}

function deserializeBoxObjectProperty(pos) {
    return deserializeObjectProperty(uint32[pos >> 2]);
}

function deserializeObjectProperty(pos) {
    return {
        type: 'ObjectProperty',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        kind: deserializePropertyKind(pos + 64),
        key: deserializePropertyKey(pos + 40),
        value: deserializeExpression(pos + 16),
        init: deserializeOptionExpression(pos),
        method: uint8[pos + 65] === 1,
        shorthand: uint8[pos + 66] === 1,
        computed: uint8[pos + 67] === 1,
    };
}

function deserializePropertyKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'init';
        case 1:
            return 'get';
        case 254:
            return 'set';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for PropertyKind`);
    }
}

function deserializeBoxParenthesizedExpression(pos) {
    return deserializeParenthesizedExpression(uint32[pos >> 2]);
}

function deserializeParenthesizedExpression(pos) {
    return {
        type: 'ParenthesizedExpression',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        expression: deserializeExpression(pos),
    };
}

function deserializeBoxSequenceExpression(pos) {
    return deserializeSequenceExpression(uint32[pos >> 2]);
}

function deserializeSequenceExpression(pos) {
    return {
        type: 'SequenceExpression',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        expressions: deserializeVecExpression(pos),
    };
}

function deserializeBoxTaggedTemplateExpression(pos) {
    return deserializeTaggedTemplateExpression(uint32[pos >> 2]);
}

function deserializeTaggedTemplateExpression(pos) {
    return {
        type: 'TaggedTemplateExpression',
        start: uint32[(pos + 88) >> 2],
        end: uint32[(pos + 92) >> 2],
        tag: deserializeExpression(pos),
        quasi: deserializeTemplateLiteral(pos + 16),
        typeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 96),
    };
}

function deserializeBoxThisExpression(pos) {
    return deserializeThisExpression(uint32[pos >> 2]);
}

function deserializeThisExpression(pos) {
    return { type: 'ThisExpression', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxUpdateExpression(pos) {
    return deserializeUpdateExpression(uint32[pos >> 2]);
}

function deserializeUpdateExpression(pos) {
    return {
        type: 'UpdateExpression',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        operator: deserializeUpdateOperator(pos + 24),
        prefix: uint8[pos + 25] === 1,
        argument: deserializeSimpleAssignmentTarget(pos),
    };
}

function deserializeUpdateOperator(pos) {
    switch (uint8[pos]) {
        case 0:
            return '++';
        case 254:
            return '--';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for UpdateOperator`);
    }
}

function deserializeBoxYieldExpression(pos) {
    return deserializeYieldExpression(uint32[pos >> 2]);
}

function deserializeYieldExpression(pos) {
    return {
        type: 'YieldExpression',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        delegate: uint8[pos + 24] === 1,
        argument: deserializeOptionExpression(pos + 8),
    };
}

function deserializeBoxPrivateInExpression(pos) {
    return deserializePrivateInExpression(uint32[pos >> 2]);
}

function deserializePrivateInExpression(pos) {
    return {
        type: 'PrivateInExpression',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        left: deserializePrivateIdentifier(pos),
        operator: deserializeBinaryOperator(pos + 48),
        right: deserializeExpression(pos + 24),
    };
}

function deserializeBoxJSXElement(pos) {
    return deserializeJSXElement(uint32[pos >> 2]);
}

function deserializeJSXElement(pos) {
    return {
        type: 'JSXElement',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        openingElement: deserializeBoxJSXOpeningElement(pos),
        closingElement: deserializeOptionBoxJSXClosingElement(pos + 48),
        children: deserializeVecJSXChild(pos + 8),
    };
}

function deserializeBoxJSXOpeningElement(pos) {
    return deserializeJSXOpeningElement(uint32[pos >> 2]);
}

function deserializeJSXOpeningElement(pos) {
    return {
        type: 'JSXOpeningElement',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        selfClosing: uint8[pos + 64] === 1,
        name: deserializeJSXElementName(pos),
        attributes: deserializeVecJSXAttributeItem(pos + 16),
        typeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 56),
    };
}

function deserializeJSXElementName(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxJSXIdentifier(pos + 8);
        case 1:
            return deserializeBoxJSXNamespacedName(pos + 8);
        case 254:
            return deserializeBoxJSXMemberExpression(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for JSXElementName`);
    }
}

function deserializeBoxJSXIdentifier(pos) {
    return deserializeJSXIdentifier(uint32[pos >> 2]);
}

function deserializeJSXIdentifier(pos) {
    return {
        type: 'JSXIdentifier',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        name: deserializeRefStr(pos),
    };
}

function deserializeBoxJSXNamespacedName(pos) {
    return deserializeJSXNamespacedName(uint32[pos >> 2]);
}

function deserializeJSXNamespacedName(pos) {
    return {
        type: 'JSXNamespacedName',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        namespace: deserializeJSXIdentifier(pos),
        property: deserializeJSXIdentifier(pos + 24),
    };
}

function deserializeBoxJSXMemberExpression(pos) {
    return deserializeJSXMemberExpression(uint32[pos >> 2]);
}

function deserializeJSXMemberExpression(pos) {
    return {
        type: 'JSXMemberExpression',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        object: deserializeJSXMemberExpressionObject(pos),
        property: deserializeJSXIdentifier(pos + 16),
    };
}

function deserializeJSXMemberExpressionObject(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxJSXIdentifier(pos + 8);
        case 254:
            return deserializeBoxJSXMemberExpression(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for JSXMemberExpressionObject`);
    }
}

function deserializeVecJSXAttributeItem(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeJSXAttributeItem(pos));
        pos += 16;
    }
    return arr;
}

function deserializeJSXAttributeItem(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxJSXAttribute(pos + 8);
        case 254:
            return deserializeBoxJSXSpreadAttribute(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for JSXAttributeItem`);
    }
}

function deserializeBoxJSXAttribute(pos) {
    return deserializeJSXAttribute(uint32[pos >> 2]);
}

function deserializeJSXAttribute(pos) {
    return {
        type: 'JSXAttribute',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        name: deserializeJSXAttributeName(pos),
        value: deserializeOptionJSXAttributeValue(pos + 24),
    };
}

function deserializeJSXAttributeName(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxJSXIdentifier(pos + 8);
        case 254:
            return deserializeBoxJSXNamespacedName(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for JSXAttributeName`);
    }
}

function deserializeOptionJSXAttributeValue(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeJSXAttributeValue(pos);
}

function deserializeJSXAttributeValue(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxStringLiteral(pos + 8);
        case 1:
            return deserializeBoxJSXExpressionContainer(pos + 8);
        case 2:
            return deserializeBoxJSXElement(pos + 8);
        case 254:
            return deserializeBoxJSXFragment(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for JSXAttributeValue`);
    }
}

function deserializeBoxJSXExpressionContainer(pos) {
    return deserializeJSXExpressionContainer(uint32[pos >> 2]);
}

function deserializeJSXExpressionContainer(pos) {
    return {
        type: 'JSXExpressionContainer',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        expression: deserializeJSXExpression(pos),
    };
}

function deserializeJSXExpression(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeExpression(pos + 8);
        case 254:
            return deserializeJSXEmptyExpression(pos + 4);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for JSXExpression`);
    }
}

function deserializeJSXEmptyExpression(pos) {
    return { type: 'JSXEmptyExpression', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxJSXFragment(pos) {
    return deserializeJSXFragment(uint32[pos >> 2]);
}

function deserializeJSXFragment(pos) {
    return {
        type: 'JSXFragment',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        openingFragment: deserializeJSXOpeningFragment(pos + 40),
        closingFragment: deserializeJSXClosingFragment(pos + 48),
        children: deserializeVecJSXChild(pos),
    };
}

function deserializeJSXOpeningFragment(pos) {
    return { type: 'JSXOpeningFragment', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeJSXClosingFragment(pos) {
    return { type: 'JSXClosingFragment', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeVecJSXChild(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeJSXChild(pos));
        pos += 16;
    }
    return arr;
}

function deserializeJSXChild(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxJSXText(pos + 8);
        case 1:
            return deserializeBoxJSXElement(pos + 8);
        case 2:
            return deserializeBoxJSXFragment(pos + 8);
        case 3:
            return deserializeBoxJSXExpressionContainer(pos + 8);
        case 254:
            return deserializeBoxJSXSpreadChild(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for JSXChild`);
    }
}

function deserializeBoxJSXText(pos) {
    return deserializeJSXText(uint32[pos >> 2]);
}

function deserializeJSXText(pos) {
    return {
        type: 'JSXText',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        value: deserializeRefStr(pos),
    };
}

function deserializeBoxJSXSpreadChild(pos) {
    return deserializeJSXSpreadChild(uint32[pos >> 2]);
}

function deserializeJSXSpreadChild(pos) {
    return {
        type: 'JSXSpreadChild',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        expression: deserializeExpression(pos),
    };
}

function deserializeBoxJSXSpreadAttribute(pos) {
    return deserializeJSXSpreadAttribute(uint32[pos >> 2]);
}

function deserializeJSXSpreadAttribute(pos) {
    return {
        type: 'JSXSpreadAttribute',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        argument: deserializeExpression(pos),
    };
}

function deserializeOptionBoxJSXClosingElement(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeBoxJSXClosingElement(pos);
}

function deserializeBoxJSXClosingElement(pos) {
    return deserializeJSXClosingElement(uint32[pos >> 2]);
}

function deserializeJSXClosingElement(pos) {
    return {
        type: 'JSXClosingElement',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        name: deserializeJSXElementName(pos),
    };
}

function deserializeBoxTSInstantiationExpression(pos) {
    return deserializeTSInstantiationExpression(uint32[pos >> 2]);
}

function deserializeTSInstantiationExpression(pos) {
    return {
        type: 'TSInstantiationExpression',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        expression: deserializeExpression(pos),
        typeParameters: deserializeBoxTSTypeParameterInstantiation(pos + 16),
    };
}

function deserializeBoxEmptyStatement(pos) {
    return deserializeEmptyStatement(uint32[pos >> 2]);
}

function deserializeEmptyStatement(pos) {
    return { type: 'EmptyStatement', start: uint32[pos >> 2], end: uint32[(pos + 4) >> 2] };
}

function deserializeBoxExpressionStatement(pos) {
    return deserializeExpressionStatement(uint32[pos >> 2]);
}

function deserializeExpressionStatement(pos) {
    return {
        type: 'ExpressionStatement',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        expression: deserializeExpression(pos),
    };
}

function deserializeBoxForInStatement(pos) {
    return deserializeForInStatement(uint32[pos >> 2]);
}

function deserializeForInStatement(pos) {
    return {
        type: 'ForInStatement',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        left: deserializeForStatementLeft(pos),
        right: deserializeExpression(pos + 32),
        body: deserializeStatement(pos + 48),
    };
}

function deserializeForStatementLeft(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxVariableDeclaration(pos + 8);
        case 1:
            return deserializeAssignmentTarget(pos + 8);
        case 254:
            return deserializeBoxUsingDeclaration(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ForStatementLeft`);
    }
}

function deserializeBoxVariableDeclaration(pos) {
    return deserializeVariableDeclaration(uint32[pos >> 2]);
}

function deserializeVariableDeclaration(pos) {
    return {
        type: 'VariableDeclaration',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        kind: deserializeVariableDeclarationKind(pos + 72),
        declarations: deserializeVecVariableDeclarator(pos),
        modifiers: deserializeOptionVecModifier(pos + 40),
    };
}

function deserializeVariableDeclarationKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'var';
        case 1:
            return 'const';
        case 254:
            return 'let';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for VariableDeclarationKind`);
    }
}

function deserializeVecVariableDeclarator(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeVariableDeclarator(pos));
        pos += 64;
    }
    return arr;
}

function deserializeVariableDeclarator(pos) {
    return {
        type: 'VariableDeclarator',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        id: deserializeBindingPattern(pos + 24),
        init: deserializeOptionExpression(pos),
        definite: uint8[pos + 57] === 1,
    };
}

function deserializeBoxUsingDeclaration(pos) {
    return deserializeUsingDeclaration(uint32[pos >> 2]);
}

function deserializeUsingDeclaration(pos) {
    return {
        type: 'UsingDeclaration',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        isAwait: uint8[pos + 40] === 1,
        declarations: deserializeVecVariableDeclarator(pos),
    };
}

function deserializeBoxForOfStatement(pos) {
    return deserializeForOfStatement(uint32[pos >> 2]);
}

function deserializeForOfStatement(pos) {
    return {
        type: 'ForOfStatement',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        await: uint8[pos + 72] === 1,
        left: deserializeForStatementLeft(pos),
        right: deserializeExpression(pos + 32),
        body: deserializeStatement(pos + 48),
    };
}

function deserializeBoxForStatement(pos) {
    return deserializeForStatement(uint32[pos >> 2]);
}

function deserializeForStatement(pos) {
    return {
        type: 'ForStatement',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        init: deserializeOptionForStatementInit(pos + 24),
        test: deserializeOptionExpression(pos + 48),
        update: deserializeOptionExpression(pos + 64),
        body: deserializeStatement(pos),
    };
}

function deserializeOptionForStatementInit(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeForStatementInit(pos);
}

function deserializeForStatementInit(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxVariableDeclaration(pos + 8);
        case 1:
            return deserializeExpression(pos + 8);
        case 254:
            return deserializeBoxUsingDeclaration(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ForStatementInit`);
    }
}

function deserializeBoxIfStatement(pos) {
    return deserializeIfStatement(uint32[pos >> 2]);
}

function deserializeIfStatement(pos) {
    return {
        type: 'IfStatement',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        test: deserializeExpression(pos),
        consequent: deserializeStatement(pos + 16),
        alternate: deserializeOptionStatement(pos + 40),
    };
}

function deserializeOptionStatement(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeStatement(pos);
}

function deserializeBoxLabeledStatement(pos) {
    return deserializeLabeledStatement(uint32[pos >> 2]);
}

function deserializeLabeledStatement(pos) {
    return {
        type: 'LabeledStatement',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        label: deserializeLabelIdentifier(pos),
        body: deserializeStatement(pos + 24),
    };
}

function deserializeBoxReturnStatement(pos) {
    return deserializeReturnStatement(uint32[pos >> 2]);
}

function deserializeReturnStatement(pos) {
    return {
        type: 'ReturnStatement',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        argument: deserializeOptionExpression(pos),
    };
}

function deserializeBoxSwitchStatement(pos) {
    return deserializeSwitchStatement(uint32[pos >> 2]);
}

function deserializeSwitchStatement(pos) {
    return {
        type: 'SwitchStatement',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        discriminant: deserializeExpression(pos),
        cases: deserializeVecSwitchCase(pos + 16),
    };
}

function deserializeVecSwitchCase(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeSwitchCase(pos));
        pos += 56;
    }
    return arr;
}

function deserializeSwitchCase(pos) {
    return {
        type: 'SwitchCase',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        test: deserializeOptionExpression(pos + 40),
        consequent: deserializeVecStatement(pos),
    };
}

function deserializeBoxThrowStatement(pos) {
    return deserializeThrowStatement(uint32[pos >> 2]);
}

function deserializeThrowStatement(pos) {
    return {
        type: 'ThrowStatement',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        argument: deserializeExpression(pos),
    };
}

function deserializeBoxTryStatement(pos) {
    return deserializeTryStatement(uint32[pos >> 2]);
}

function deserializeTryStatement(pos) {
    return {
        type: 'TryStatement',
        start: uint32[(pos + 8) >> 2],
        end: uint32[(pos + 12) >> 2],
        block: deserializeBoxBlockStatement(pos),
        handler: deserializeOptionBoxCatchClause(pos + 16),
        finalizer: deserializeOptionBoxBlockStatement(pos + 24),
    };
}

function deserializeOptionBoxCatchClause(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeBoxCatchClause(pos);
}

function deserializeBoxCatchClause(pos) {
    return deserializeCatchClause(uint32[pos >> 2]);
}

function deserializeCatchClause(pos) {
    return {
        type: 'CatchClause',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        param: deserializeOptionCatchParameter(pos + 16),
        body: deserializeBoxBlockStatement(pos + 8),
    };
}

function deserializeOptionCatchParameter(pos) {
    if (uint8[pos + 32] === 2) return null;
    return deserializeCatchParameter(pos);
}

function deserializeCatchParameter(pos) {
    return {
        type: 'CatchParameter',
        start: uint32[pos >> 2],
        end: uint32[(pos + 4) >> 2],
        pattern: deserializeBindingPattern(pos + 8),
    };
}

function deserializeOptionBoxBlockStatement(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeBoxBlockStatement(pos);
}

function deserializeBoxWhileStatement(pos) {
    return deserializeWhileStatement(uint32[pos >> 2]);
}

function deserializeWhileStatement(pos) {
    return {
        type: 'WhileStatement',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        test: deserializeExpression(pos),
        body: deserializeStatement(pos + 16),
    };
}

function deserializeBoxWithStatement(pos) {
    return deserializeWithStatement(uint32[pos >> 2]);
}

function deserializeWithStatement(pos) {
    return {
        type: 'WithStatement',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        object: deserializeExpression(pos),
        body: deserializeStatement(pos + 16),
    };
}

function deserializeBoxModuleDeclaration(pos) {
    return deserializeModuleDeclaration(uint32[pos >> 2]);
}

function deserializeModuleDeclaration(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxImportDeclaration(pos + 8);
        case 1:
            return deserializeBoxExportAllDeclaration(pos + 8);
        case 2:
            return deserializeBoxExportDefaultDeclaration(pos + 8);
        case 3:
            return deserializeBoxExportNamedDeclaration(pos + 8);
        case 4:
            return deserializeBoxTSExportAssignment(pos + 8);
        case 254:
            return deserializeBoxTSNamespaceExportDeclaration(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ModuleDeclaration`);
    }
}

function deserializeBoxImportDeclaration(pos) {
    return deserializeImportDeclaration(uint32[pos >> 2]);
}

function deserializeImportDeclaration(pos) {
    return {
        type: 'ImportDeclaration',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        specifiers: deserializeOptionVecImportDeclarationSpecifier(pos + 32),
        source: deserializeStringLiteral(pos),
        withClause: deserializeOptionWithClause(pos + 64),
        importKind: deserializeImportOrExportKind(pos + 128),
    };
}

function deserializeOptionVecImportDeclarationSpecifier(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeVecImportDeclarationSpecifier(pos);
}

function deserializeVecImportDeclarationSpecifier(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeImportDeclarationSpecifier(pos));
        pos += 16;
    }
    return arr;
}

function deserializeImportDeclarationSpecifier(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxImportSpecifier(pos + 8);
        case 1:
            return deserializeBoxImportDefaultSpecifier(pos + 8);
        case 254:
            return deserializeBoxImportNamespaceSpecifier(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ImportDeclarationSpecifier`);
    }
}

function deserializeBoxImportSpecifier(pos) {
    return deserializeImportSpecifier(uint32[pos >> 2]);
}

function deserializeImportSpecifier(pos) {
    return {
        type: 'ImportSpecifier',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        imported: deserializeModuleExportName(pos),
        local: deserializeBindingIdentifier(pos + 32),
        importKind: deserializeImportOrExportKind(pos + 72),
    };
}

function deserializeModuleExportName(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeIdentifierName(pos + 8);
        case 254:
            return deserializeStringLiteral(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ModuleExportName`);
    }
}

function deserializeImportOrExportKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'value';
        case 254:
            return 'type';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ImportOrExportKind`);
    }
}

function deserializeBoxImportDefaultSpecifier(pos) {
    return deserializeImportDefaultSpecifier(uint32[pos >> 2]);
}

function deserializeImportDefaultSpecifier(pos) {
    return {
        type: 'ImportDefaultSpecifier',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        local: deserializeBindingIdentifier(pos),
    };
}

function deserializeBoxImportNamespaceSpecifier(pos) {
    return deserializeImportNamespaceSpecifier(uint32[pos >> 2]);
}

function deserializeImportNamespaceSpecifier(pos) {
    return {
        type: 'ImportNamespaceSpecifier',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        local: deserializeBindingIdentifier(pos),
    };
}

function deserializeOptionWithClause(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeWithClause(pos);
}

function deserializeWithClause(pos) {
    return {
        type: 'WithClause',
        start: uint32[(pos + 56) >> 2],
        end: uint32[(pos + 60) >> 2],
        attributesKeyword: deserializeIdentifierName(pos),
        withEntries: deserializeVecImportAttribute(pos + 24),
    };
}

function deserializeVecImportAttribute(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeImportAttribute(pos));
        pos += 64;
    }
    return arr;
}

function deserializeImportAttribute(pos) {
    return {
        type: 'ImportAttribute',
        start: uint32[(pos + 56) >> 2],
        end: uint32[(pos + 60) >> 2],
        key: deserializeImportAttributeKey(pos),
        value: deserializeStringLiteral(pos + 32),
    };
}

function deserializeImportAttributeKey(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeIdentifierName(pos + 8);
        case 254:
            return deserializeStringLiteral(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for ImportAttributeKey`);
    }
}

function deserializeBoxExportAllDeclaration(pos) {
    return deserializeExportAllDeclaration(uint32[pos >> 2]);
}

function deserializeExportAllDeclaration(pos) {
    return {
        type: 'ExportAllDeclaration',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        exported: deserializeOptionModuleExportName(pos + 32),
        source: deserializeStringLiteral(pos),
        withClause: deserializeOptionWithClause(pos + 64),
        exportKind: deserializeImportOrExportKind(pos + 128),
    };
}

function deserializeOptionModuleExportName(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeModuleExportName(pos);
}

function deserializeBoxExportDefaultDeclaration(pos) {
    return deserializeExportDefaultDeclaration(uint32[pos >> 2]);
}

function deserializeExportDefaultDeclaration(pos) {
    return {
        type: 'ExportDefaultDeclaration',
        start: uint32[(pos + 56) >> 2],
        end: uint32[(pos + 60) >> 2],
        declaration: deserializeExportDefaultDeclarationKind(pos),
        exported: deserializeModuleExportName(pos + 24),
    };
}

function deserializeExportDefaultDeclarationKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeExpression(pos + 8);
        case 1:
            return deserializeBoxFunction(pos + 8);
        case 2:
            return deserializeBoxClass(pos + 8);
        case 3:
            return deserializeBoxTSInterfaceDeclaration(pos + 8);
        case 254:
            return deserializeBoxTSEnumDeclaration(pos + 8);
        default:
            throw new Error(
                `Unexpected discriminant ${uint8[pos]} for ExportDefaultDeclarationKind`,
            );
    }
}

function deserializeBoxTSInterfaceDeclaration(pos) {
    return deserializeTSInterfaceDeclaration(uint32[pos >> 2]);
}

function deserializeTSInterfaceDeclaration(pos) {
    return {
        type: 'TSInterfaceDeclaration',
        start: uint32[(pos + 40) >> 2],
        end: uint32[(pos + 44) >> 2],
        id: deserializeBindingIdentifier(pos),
        body: deserializeBoxTSInterfaceBody(pos + 32),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 48),
        extends: deserializeOptionVecTSInterfaceHeritage(pos + 56),
        modifiers: deserializeOptionVecModifier(pos + 88),
    };
}

function deserializeBoxTSInterfaceBody(pos) {
    return deserializeTSInterfaceBody(uint32[pos >> 2]);
}

function deserializeTSInterfaceBody(pos) {
    return {
        type: 'TSInterfaceBody',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        body: deserializeVecTSSignature(pos),
    };
}

function deserializeOptionVecTSInterfaceHeritage(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeVecTSInterfaceHeritage(pos);
}

function deserializeVecTSInterfaceHeritage(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTSInterfaceHeritage(pos));
        pos += 32;
    }
    return arr;
}

function deserializeTSInterfaceHeritage(pos) {
    return {
        type: 'TSInterfaceHeritage',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        expression: deserializeExpression(pos),
        typeParameters: deserializeOptionBoxTSTypeParameterInstantiation(pos + 24),
    };
}

function deserializeBoxTSEnumDeclaration(pos) {
    return deserializeTSEnumDeclaration(uint32[pos >> 2]);
}

function deserializeTSEnumDeclaration(pos) {
    return {
        type: 'TSEnumDeclaration',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        id: deserializeBindingIdentifier(pos),
        members: deserializeVecTSEnumMember(pos + 32),
        modifiers: deserializeOptionVecModifier(pos + 72),
    };
}

function deserializeVecTSEnumMember(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeTSEnumMember(pos));
        pos += 48;
    }
    return arr;
}

function deserializeTSEnumMember(pos) {
    return {
        type: 'TSEnumMember',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        id: deserializeTSEnumMemberName(pos),
        initializer: deserializeOptionExpression(pos + 32),
    };
}

function deserializeTSEnumMemberName(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxIdentifierName(pos + 8);
        case 1:
            return deserializeBoxStringLiteral(pos + 8);
        case 2:
            return deserializeExpression(pos + 8);
        case 254:
            return deserializeBoxNumericLiteral(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSEnumMemberName`);
    }
}

function deserializeBoxExportNamedDeclaration(pos) {
    return deserializeExportNamedDeclaration(uint32[pos >> 2]);
}

function deserializeExportNamedDeclaration(pos) {
    return {
        type: 'ExportNamedDeclaration',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        declaration: deserializeOptionDeclaration(pos),
        specifiers: deserializeVecExportSpecifier(pos + 16),
        source: deserializeOptionStringLiteral(pos + 56),
        exportKind: deserializeImportOrExportKind(pos + 144),
        withClause: deserializeOptionWithClause(pos + 80),
    };
}

function deserializeOptionDeclaration(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeDeclaration(pos);
}

function deserializeDeclaration(pos) {
    switch (uint8[pos]) {
        case 19:
            return deserializeBoxVariableDeclaration(pos + 8);
        case 21:
            return deserializeBoxFunction(pos + 8);
        case 22:
            return deserializeBoxClass(pos + 8);
        case 23:
            return deserializeBoxUsingDeclaration(pos + 8);
        case 24:
            return deserializeBoxTSTypeAliasDeclaration(pos + 8);
        case 25:
            return deserializeBoxTSInterfaceDeclaration(pos + 8);
        case 26:
            return deserializeBoxTSEnumDeclaration(pos + 8);
        case 27:
            return deserializeBoxTSModuleDeclaration(pos + 8);
        case 254:
            return deserializeBoxTSImportEqualsDeclaration(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for Declaration`);
    }
}

function deserializeBoxTSTypeAliasDeclaration(pos) {
    return deserializeTSTypeAliasDeclaration(uint32[pos >> 2]);
}

function deserializeTSTypeAliasDeclaration(pos) {
    return {
        type: 'TSTypeAliasDeclaration',
        start: uint32[(pos + 48) >> 2],
        end: uint32[(pos + 52) >> 2],
        id: deserializeBindingIdentifier(pos),
        typeAnnotation: deserializeTSType(pos + 32),
        typeParameters: deserializeOptionBoxTSTypeParameterDeclaration(pos + 56),
        modifiers: deserializeOptionVecModifier(pos + 64),
    };
}

function deserializeBoxTSModuleDeclaration(pos) {
    return deserializeTSModuleDeclaration(uint32[pos >> 2]);
}

function deserializeTSModuleDeclaration(pos) {
    return {
        type: 'TSModuleDeclaration',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        id: deserializeTSModuleDeclarationName(pos),
        body: deserializeOptionTSModuleDeclarationBody(pos + 40),
        kind: deserializeTSModuleDeclarationKind(pos + 88),
        modifiers: deserializeOptionVecModifier(pos + 56),
    };
}

function deserializeTSModuleDeclarationName(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeIdentifierName(pos + 8);
        case 254:
            return deserializeStringLiteral(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSModuleDeclarationName`);
    }
}

function deserializeOptionTSModuleDeclarationBody(pos) {
    if (uint8[pos] === 255) return null;
    return deserializeTSModuleDeclarationBody(pos);
}

function deserializeTSModuleDeclarationBody(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeBoxTSModuleDeclaration(pos + 8);
        case 254:
            return deserializeBoxTSModuleBlock(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSModuleDeclarationBody`);
    }
}

function deserializeBoxTSModuleBlock(pos) {
    return deserializeTSModuleBlock(uint32[pos >> 2]);
}

function deserializeTSModuleBlock(pos) {
    return {
        type: 'TSModuleBlock',
        start: uint32[(pos + 32) >> 2],
        end: uint32[(pos + 36) >> 2],
        body: deserializeVecStatement(pos),
    };
}

function deserializeTSModuleDeclarationKind(pos) {
    switch (uint8[pos]) {
        case 0:
            return 'global';
        case 1:
            return 'module';
        case 254:
            return 'namespace';
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSModuleDeclarationKind`);
    }
}

function deserializeBoxTSImportEqualsDeclaration(pos) {
    return deserializeTSImportEqualsDeclaration(uint32[pos >> 2]);
}

function deserializeTSImportEqualsDeclaration(pos) {
    return {
        type: 'TSImportEqualsDeclaration',
        start: uint32[(pos + 56) >> 2],
        end: uint32[(pos + 60) >> 2],
        id: deserializeBindingIdentifier(pos),
        moduleReference: deserializeTSModuleReference(pos + 32),
        importKind: deserializeImportOrExportKind(pos + 64),
    };
}

function deserializeTSModuleReference(pos) {
    switch (uint8[pos]) {
        case 0:
            return deserializeTSTypeName(pos + 8);
        case 254:
            return deserializeBoxTSExternalModuleReference(pos + 8);
        default:
            throw new Error(`Unexpected discriminant ${uint8[pos]} for TSModuleReference`);
    }
}

function deserializeBoxTSExternalModuleReference(pos) {
    return deserializeTSExternalModuleReference(uint32[pos >> 2]);
}

function deserializeTSExternalModuleReference(pos) {
    return {
        type: 'TSExternalModuleReference',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        expression: deserializeStringLiteral(pos),
    };
}

function deserializeVecExportSpecifier(pos) {
    const arr = [],
        pos32 = pos >> 2,
        len = uint32[pos32 + 6];
    pos = uint32[pos32];
    for (let i = 0; i < len; i++) {
        arr.push(deserializeExportSpecifier(pos));
        pos += 80;
    }
    return arr;
}

function deserializeExportSpecifier(pos) {
    return {
        type: 'ExportSpecifier',
        start: uint32[(pos + 64) >> 2],
        end: uint32[(pos + 68) >> 2],
        local: deserializeModuleExportName(pos),
        exported: deserializeModuleExportName(pos + 32),
        exportKind: deserializeImportOrExportKind(pos + 72),
    };
}

function deserializeOptionStringLiteral(pos) {
    if (uint32[pos >> 2] === 0 && uint32[(pos + 4) >> 2] === 0) return null;
    return deserializeStringLiteral(pos);
}

function deserializeBoxTSExportAssignment(pos) {
    return deserializeTSExportAssignment(uint32[pos >> 2]);
}

function deserializeTSExportAssignment(pos) {
    return {
        type: 'TSExportAssignment',
        start: uint32[(pos + 16) >> 2],
        end: uint32[(pos + 20) >> 2],
        expression: deserializeExpression(pos),
    };
}

function deserializeBoxTSNamespaceExportDeclaration(pos) {
    return deserializeTSNamespaceExportDeclaration(uint32[pos >> 2]);
}

function deserializeTSNamespaceExportDeclaration(pos) {
    return {
        type: 'TSNamespaceExportDeclaration',
        start: uint32[(pos + 24) >> 2],
        end: uint32[(pos + 28) >> 2],
        id: deserializeIdentifierName(pos),
    };
}
